#set par(first-line-indent: 0cm, leading: 0.50em, justify: true)
#set text(lang: "bg", font: "New Computer Modern", hyphenate: false, size: 14pt)
#show raw: set text(font: "New Computer Modern Mono")
#show math.equation: set text(style: "italic")
#show par: set block(spacing: 1.5em)
#show heading: set block(above: 1.4em, below: 1em)
#set heading(supplement: "Глава")
#set figure(supplement: "Фигура")

#let печатно = math.upright
#let атан2 = math.op(печатно("атан2"))
#let корен = math.sqrt
#let пи = math.pi
#let син = math.op(печатно("син"))
#let кос = math.op(печатно("кос"))
#let частно = math.frac
#let съкращаваме = math.cancel

#set heading(numbering: (..nums) => {
	let heading_funcs = (
		(num) => str(num),
		(num) => "абвгдежзийклмнопрстуфхцчшщъьюя".clusters().at(num - 1),
	)
	nums
		.pos()
		.enumerate()
		.map(((depth, num)) => heading_funcs.at(calc.rem-euclid(depth, heading_funcs.len()))(num))
		.join(".")
})

#let todo(content) = text(red, content)

#let ai(content) = text(blue, content)

#page[#grid(rows: (1fr, 1fr, 1fr, 1fr, 1fr),
	[
		#set text(14pt)
		#set align(center + top)
		#set par(justify: false)
		#smallcaps[Технологично училище „Електронни системи“ към Технически университет - София]
	],

	[
		#set align(center + horizon)
		#set text(24pt)
		#smallcaps[Дипломна работа]

		#set text(11pt)
		по професия код 481020  „Системен програмист“ \
		специалност код 4810201 „Системно програмиране“
	],

	align(center + horizon)[#set text(14pt); Тема: Мехатронен паяк],

	align(bottom)[#grid(
		columns: (1fr, 1fr),
		align(left)[Дипломант: \ #text(11pt)[Теодор Цветалинов Тотев]],
		align(right)[Дипломен ръководител: \ #text(11pt)[Станислав Николов]],
	)],

	align(center + bottom)[#set text(14pt); #smallcaps[София \ 2024]],
)]

#page[#todo[Задание]]

// #page[Отзив на научния ръководител и предложение за рецензент]
#page[]

#heading(numbering: none)[Увод]
#todo[Кратко въведение в областта ( максимум 1 -2 стр.). В края на увода да бъдат поставени целите и задачите на ДР;]

#ai[
През последните години в областта на роботиката се наблюдава значителен напредък, като роботите стават все по-сложни и гъвкави. Тъй като роботите продължават да се интегрират все повече в различни индустрии и приложения, нараства необходимостта от роботи, които могат да се ориентират в сложни среди и да изпълняват задачи, които са трудни или опасни за хората. Една от обещаващите области на изследване е разработването на роботи на крака, които могат да преминават през неравен терен и да се ориентират в препятствия с по-голяма лекота, отколкото роботите на колела или гъсенични машини.

Настоящата дипломна работа се фокусира върху създаването на четирикрак робот-паяк, който съчетава предимствата на крачната локомоция с гъвкавостта и адаптивността на структурата на краката на паяка. Роботът паяк е проектиран да бъде високо маневрен и способен да се движи в широк спектър от среди - от индустриални условия до сценарии за реакция при бедствия.

Разработването на робота-паяк включва няколко ключови предизвикателства, включително проектирането на краката и системата за придвижване на робота, разработването на алгоритми за управление за стабилно и ефективно движение и интегрирането на сензори за възприемане на околната среда и навигация. В настоящата дисертация ще бъдат разгледани тези предизвикателства и ще бъде представен нов подход към проектирането и управлението на четирикрак робот-паяк.

Предложеният робот-паяк се основава на предишни изследвания в областта на движението на краката и роботиката, вдъхновена от паяци, но с акцент върху създаването на високо адаптивна и универсална платформа за широк спектър от приложения. Краката на робота са проектирани така, че да осигуряват стабилност и мобилност, а алгоритмите за управление са оптимизирани за енергийна ефективност и маневреност. Освен това роботът-паяк е оборудван с набор от сензори за възприемане на околната среда и навигация, включително камери, лидар и ултразвукови сензори.

Потенциалните приложения на робота-паяк са многобройни - от индустриални инспекции и поддръжка до операции по търсене и спасяване в райони, засегнати от бедствия. Съчетавайки предимствата на локомоцията на краката с гъвкавостта на структурата на краката на паяка, роботът паяк представлява значителна стъпка напред в областта на роботиката и има потенциала да революционизира начина, по който подхождаме към сложните задачи в различни индустрии.

В следващите глави ще разгледаме подробно проектирането и разработването на робота паяк, включително механичната конструкция на краката, алгоритмите за управление за стабилно и ефективно движение и интегрирането на сензори за възприемане на околната среда и навигация. Ще представим и експериментални резултати, демонстриращи възможностите на робота и потенциалните му приложения.
]

= Проучване
#todo[Представлява проучвателната част на ДР. Прави се преглед на съществуващи хардуерни разработки, на използваната елементна база, основни принципи и методи за обработка на сигнали и информация ( максимум 8-10 страници) ;]
#todo[esp32]

== Свобода <свобода>
#ai[
Свободният софтуер, известен също като libre software, се отнася до компютърен софтуер, който се разпространява при условия, позволяващи на потребителите да имат достъп до изходния код на софтуера, да го променят и разпространяват. Терминът "свободен" в свободния софтуер се отнася до свободата, а не до цената, което означава, че потребителите имат свободата да използват, изучават, променят и разпространяват софтуера, без да е необходимо да плащат лицензионни такси или възнаграждения.

Концепцията за свободен софтуер се основава на четири основни свободи, както са определени от Фондацията за свободен софтуер:

- *Свобода 0:* Свободата да се използва програмата за всякакви цели.
- *Свобода 1:* Свободата да изучавате как работи програмата и да я променяте, за да я накарате да прави това, което желаете.
- *Свобода 2:* Свободата да разпространявате копия на програмата, за да можете да помагате на други хора.
- *Свобода 3:* Свободата да разпространявате копия на променените от вас версии на други хора.

Свободният софтуер често се разработва и поддържа от общности от доброволци и организации, които допринасят за развитието и подобряването на софтуера. Тези общности често използват модели за съвместна разработка, като например разработване на софтуер с отворен код, за да създават висококачествен софтуер, който е свободно достъпен за всички.

Свободният софтуер има няколко предимства пред несвободния софтуер. От една страна, той позволява на потребителите да персонализират и променят софтуера, за да отговаря на техните специфични нужди. Той също така насърчава прозрачността, тъй като потребителите имат достъп до изходния код на софтуера и могат да го проверяват за потенциални уязвимости в сигурността или други проблеми. Освен това свободният софтуер може да спомогне за намаляване на разходите на организациите и физическите лица, тъй като от тях не се изисква да плащат лицензионни такси или възнаграждения.

Примери за популярен свободен софтуер са операционната система Linux, уеб сървърът Apache, софтуерът за редактиране на изображения GIMP и пакетът за производителност LibreOffice. Като насърчава сътрудничеството, прозрачността и свободата, свободният софтуер се е превърнал в съществена част от съвременния софтуерен пейзаж.
]

== Микроконтролер

_Микроконтролерът_ е компактна интегрална схема, предназначена за управление на определена дейност или набор от дейности в дадена вградена система.
Фактически, микроконтролерът представлява малък компютър под формата на чип, снабден с процесор, памет и периферни интерфейси.
Той може да изпълнява инструкции, да обработва данни и да комуникира с други устройства.

Микроконтролерите са неизменна част от модерният свят.
Срещат се в автомобилистиката, индустрията, медицинските уреди, авиацията, потребителските уреди, земеделието и почти всички други отрасли.
Проектирани са по такъв начин, че да имат много възможности, но и да бъдат сравнително евтини.

Поради широкият обхват на термина, микроконтролерите се срещат в множество разновидности и се различават помежду си по много начини.
Въпреки това повечето микроконтролери имат следните части:
- *Централeн процесор* Централният процесор представлява _мозъкът_ на микроконтролера.
  Той отговаря за изпълнението на инструкциите и управлява цялостната работа на устройството.
  Обикновено той включва аритметично-логическо устройство за извършване на математически и логически операции.
  Централният процесор е способен условно да изпълнява една или друга част на програмата.
  Това негово свойство му позволява да изпълнява сложни алгоритми, а не само да пресмята математически формули.

- *Памет* Микроконтролерите имат вградена в чипа памет за съхранение на инструкции и данни. Тази памет може да бъде разделена на няколко категории, включително:

  - *Постоянна памет* #footnote[В англоезичната литература се среща като _ROM (read only memory)_]
    Този вид памет се използва за съхранение на фърмуера на микроконтролера.
    Обикновено постоянната памет е енергонезависима, което означава, че съдържанието ѝ се пази независимо от наличието на захранване.
  - *Памет с произволен достъп* Още наречена _оперативна памет_ или _работна памет_.
    Използва се за съхранение на данни които трябва да се достъпват и променят по време на работата на микроконтролера.
    Често тази памет е енергозависима, което означава, че нейното съдържание се изтрива при загуба на захранване.
  - *Електрически изтриваема програмируема постоянна памет* #footnote[В англоезичната литература се среща като _EEPROM (electrically erasable programmable ROM)_]
    Вид енергонезависима памет, която може да се изтрива и препрограмира по електронен път.
    В нея се съхранява кода на потребителя по време на програмиране на микроконтролера, както и конфигурационни данни.

- *Периферни интерфейси* Микроконтролерите обикновено включват различни периферни интерфейси за комуникация с други устройства или сензори.
  Примери за такива интерфейси са:

  - *Аналогово-цифрови преобразуватели (АЦП)* Позволяват на микроконтролера да преобразува входни аналогови сигнали в цифрови стойностти, и съответно да може да ги обработва.
    Повечето АЦП-та преобразуват напрежение, но съществуват и такива, които преобразуват ток.
    Всяко АЦП има характеристики, като резолюция, точност, скорост и т.н.
  - *Цифрово-аналогови преобразуватели (ЦАП)* Позволяват на микроконтролера да създава аналогови сигнали.
    Фактически ЦАП представлява реципрочният интерфейс на АЦП и като такъв споделя много от неговите характеристики (резолюция, точност, скорост и т.н.).
    Тези интерфейси са по-скъпи за производство и заради това се срещат по рядко в микроконтролерите.
    На тяхно място често се използва шим (@шим).
  - *Серийни комуникационни интерфейси* Позволяват на микроконтролера да комуникира с други устройства, използвайки серийни комуникационни протоколи.
    Примери за такива протоколи са _UART_ _SPI_ и _I²C_

- *Таймери и броячи* Таймерите и броячите позволяват на микроконтролера да измерва времеви интервали и реагира на времеви интервали.
  Тези части могат да се използват за разнообразни цели, като например генериране на сигнали за широчинно-импулсна модулация (ШИМ) или за насрочване на здачачи във времето.

- *Входно-изходни щифтове с общо предназначение (ВИЩОП #footnote[Терминът _ВИЩОП_ не е общоприет. В англоезичната литература това понятие се среща като _GPIO_.])*
  Чрез тези щифтове, микроконтролерът взаимодейства със сензори и други компютри.
  Отделните ВИЩОП-и на един микроконтролер могат да имат различаващи се възможностти.
  Някои от възможностите включват:

  - *Цифров вход/изход:* тези щифтове могат да се използват за връзка цифрови компоненти, като копчета и светодиоди.
  - *Аналогов вход/изход:* тези щифтове са свързани с АЦП/ЦАП и могат да се използват за връзка с аналогови компоненти.
    Поради високата цена на ЦАП-овете, микроконтролерите с аналогов изход за по-малобройни.
  - *Шим изход:* тези щифтове поддържат шим (@шим).
    Често се използват като алтернатива на аналогови изходи.
    Използват се при управление на серводвигателя SG90 (@серво).
  - *Комуникационни интерфейси:* това са щифтове които поддържат даден вид серийна комуникация, например _UART_ _SPI_ и _I²C_.
  Често се случва щифтовете да имат комбинирани възможностти (например шим и I²C).
  В такъв случай потребителят няма как да използва и двете.
  Това явление трябва да се взима предвид при проектирането на система и избирането на микроконтролер.

Фактически микроконтролерите се явяват неизменна част от всеки проект в областта на вградените системи.
Вградените в тях комуникации и ниските им цени им позволяват да бъдат използвани за голям набор от задачи.

https://bg.wikipedia.org/wiki/%D0%90%D1%80%D0%B8%D1%82%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%BD%D0%BE-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE
https://bg.wikipedia.org/wiki/ROM
https://bg.wikipedia.org/wiki/%D0%9F%D0%B0%D0%BC%D0%B5%D1%82_%D1%81_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D0%B5%D0%BD_%D0%B4%D0%BE%D1%81%D1%82%D1%8A%D0%BF
https://bg.glosbe.com/en/bg/read-only%20memory

=== Ардуйно <ардуйно>

_Ардуйно_ е свободна (@свобода) платформа за електроника, целяща да предостави лесен за използване хардуер и софтуер.
Създадена е, за да направи електрониката по-достъпна за хората без професионално минало в нея.

Платформата _Ардуйно_ се състои от две основни части - множество модели платки с микроконтролер и среда за разработка.

Средата за разработка на Ардуйно е софтуерно приложение, работещо на Уиндоус, Мак, Линукс и в облака.
Основана е на средата за разработване на компютърно изкуство _Processing_.
Тя позволява на потребителя да извършва ключови действия при разработката на проект:
/ Инсталиране на библиотеки: Средата позволява лесно да се добавят библиотеки, писани от други.
  Тези библиотеки често абстрахират определен хардуер и предоставят прост начин за взаимодействие с него.
  Споделянето на код в общността е насърчено чрез тази възможност на средата.
/ Писане на код: Ардуйно има собствен език за програмиране, основан на езиците _Wiring_ и _Ц++_.
  Средата предлага на потребителя автоматично довършване по време на писане, оцветяване на различните
  синтактични части на кода и автоматично форматиране.
/ Качване върху платката: #todo[]
/ Отстраняване на бъгове: #todo[]

Платките на Ардуйно се предлагат в множество модели разделени в няколко главни семейства:
- *Нано* e набор от малки платки с разнообразни функции.
  В зависимост от нуждата, платките могат да бъдат както по-основни, като _Nano Every_,
  така и по-разширени, като _Nano 33 BLE Sense_ и _Nano RP2040 Connect_.
  По-разширените модели разполагат с радиомодули за Bluetooth и Wi-Fi и с вградени сензори за измерване на температура, влажност, налягане, жестове, микрофон и други.
  Съвместими са с MicroPython и поддържат машинно обучение.
- *Мкр* представлява група от платки, щитове и носители, които могат да се комбинират, за да създадат разнообразни проекти без нужда от допълнителни схеми.
  Всяка платка, изключае _MKR Zero_, е снабдена с радиомодул позволяващ Wi-Fi, Bluetooth®, LoRa®, Sigfox и NB-IoT комуникации.
  Всички платки в тази серия използват енергийно ефективния 32-битов процесор _Cortex-M0 SAMD21_.
  Обурудвани са и с криптографски чип за осигурена комуникация. \
  Щитовете и носителите на Мкр се използват за разширяване на възможностите на платката. Например, те позволяват добавянето на сензори за околната среда, GPS, Ethernet, управление на двигатели и RGB матрица.
- *Класическото семейство* вклучва платки като прословутото _Ардуйно Уно_.
  В него са и моделите _Леонардо_ и _Микро_.
  Тези платки играят ключова роля в Ардуйно проекта и се ползват с голям успех през годините, като тяхното влияние не спира да расте.
- *Мега* e семейство от платки, предоставящи голяма изчислителна способност и голям брой вищопи.

Ардуйно има голяма и активна общност от потребители.
В нея те допринасят за развитието на платформата, като споделят своите проекти и знания чрез форуми, блогове и други онлайн ресурси.
С времето е създадена огромна библиотека от код и уроци.
Това улеснява начинаещите потребители да създадат първите си проекти, а опитните - да изследват нови идеи.

Гореописаните качества правят Ардуйно платформа, която съчетава свободен и лесен за използване хардуер и софтуер, за да направи електрониката достъпна за широк кръг потребители.
Гъвкавостта, достъпността и подкрепата на общността я правят идеална платформа за създаване на прототипи, обучение и експериментиране с електрониката и програмирането.


https://www.arduino.cc/en/Guide/Introduction
https://docs.arduino.cc/software/ide/#ide-v2
https://docs.arduino.cc/arduino-cloud/guides/cloud-editor/
https://www.arduino.cc/en/hardware
https://processing.org/
http://wiring.org.co/

=== Есп32
_Есп32_ е серия евтини микроконтролери с ниска консумация на енергия, вградени в чип.
Всички издания от серията имат вградени Wi-Fi и Bluetooth с два режима.
Микроконтролерите са разработени и продавани от китайската компания _Espressif Systems_.
Серията _Есп32_ съдържа няколко микроконтролера, различаващи се по тактова честота (от 160МХц до 240МХц) и оперативна памет (от 128кБ до 520кБ).

Микроконтролерите Есп32 са високоинтегрирани, като съдържат широк набор от периферни интерфейси, включително SPI, I²S, I²C, UART, SD/SDIO, CSI-2, DMA и шим и др.
Те разполагат и с няколко функции за сигурност, като защитено зареждане, криптиране на флаш памет и защитен JTAG, което ги прави подходящи за широк спектър от приложения за IoT.

Едно от най-значимите предимства на микроконтролерите ESP32 са техните интегрирани Wi-Fi и Bluetooth възможности, които им позволяват да участват в безжични комуникационни мрежи и да се свързват лесно с други устройства.
Wi-Fi модулът поддържа протоколи IEEE 802.11 b/g/n/e/k, а Bluetooth модулът поддържа протоколи Bluetooth Classic и BLE (Bluetooth Low Energy).

Микроконтролерите Есп32 могат да се програмират с помощта на различни среди за разработка. Някои от тях са:
- *Арудийно* Както е споменато в @ардуйно, платформата предоставя среда за разработка.
  Тази среда може да се използва за да се програмират микроконтролери, които не са пряко свързани с Ардуйно.
  Използвайки нея, потребителя получава удобен и познат за него интерфейс, който улеснява начинаещите потребители в програмирането на Есп32.
  Интерфейсът е и портативен, тъй като е достъпен на Ундоус, Мак и Линукс.
  Ардуйно средата дава и достъп до голямата общност на платформата, което означава голям брой ресурси и примери.
  Освен ресурси и примери, общността е произвела и голям набор от библиотеки, които в някои случаи могат да спестят много време и усилия при изпълнението на проект.

  Използването на Ардуйно средата носи своите недостатъци.
  Такива например са не толкова добрата инфраструктура за отстраняване на грешки, което може значително да забави изпълнението на проекта.
  Използвнето на Ардуйно платформата ограничава достъпа до функции предоставени от по-силният Есп32.
  Най-сериозните такива функции са възможността за няколко нишки и използването на Bluetooth.
  Ограничен е и достъпа до по-силни функции на програмният език, като шаблони и пространства от имена.
- *Ръст*
  #ai[
  1. Безопасност на паметта: Rust е език, безопасен за паметта, което означава, че предотвратява често срещани грешки в паметта, като например препращане към нулев указател, препълване на буфера и състезания с данни. Това е особено важно за вградени системи като ESP32, където паметта е ограничена и грешките могат да имат тежки последици.
  2. Производителност: Rust има производителност, подобна на тази на C и C++, което го прави отличен избор за системно програмиране. Ограничените ресурси на ESP32 изискват ефективно използване на паметта и изчислителната мощ, което прави производителността на Rust значително предимство.
  3. Съвместимост: Моделът на собственост на Rust и вградената поддръжка на паралелност го правят отличен избор за разработване на паралелни системи. Възможностите на WiFi и Bluetooth на ESP32 изискват ефективна обработка на множество връзки и потоци от данни, което прави ценна функцията за едновременност на Rust.
  4. Оперативна съвместимост: Rust има добра оперативна съвместимост с езика C, което позволява използването на съществуващи библиотеки и драйвери на C за ESP32. Това може да спести време и усилия при разработването на приложения за ESP32.
  5. Общност: Rust има разрастваща се и активна общност, което означава, че има много налични ресурси за обучение и отстраняване на проблеми. Това е особено важно за начинаещите, които не са запознати с Rust или с разработването на вградени системи.

  1. Крива на обучение: Rust има стръмна крива на усвояване, особено за тези, които са нови в системното програмиране. Синтаксисът и концепциите могат да бъдат предизвикателство за усвояване, а документацията може да бъде оскъдна в някои области.
  2. Инструменти: Въпреки че инструментариумът на Rust се подобрява, той все още не е толкова зрял, колкото други езици. Ограничените ресурси на ESP32 могат да направят дебъгването и профилирането по-трудни, а липсата на зрели инструменти може да задълбочи тези проблеми.
  3. Размер: Размерът на двоичните файлове на Rust може да бъде по-голям от този на C или C++, което може да бъде проблем за вградените системи с ограничена памет. Това може да се намали чрез използване на техники като оптимизация по време на свързване и премахване на кода.
  4. Екосистема: Въпреки че екосистемата на Rust се разраства, тя все още не е толкова обширна, колкото при други езици. Това може да направи намирането на библиотеки и драйвери по-трудно и да изисква повече време и усилия за разработване на персонализирани решения.
  5. Хардуерна поддръжка: Поддръжката на хардуер в Rust се подобрява, но все още не е толкова обширна, колкото при други езици. Това може да направи по-трудно свързването с хардуерната периферия на ESP32 и може да изисква повече програмиране на ниско ниво.
  ]
- *esp-idf*
  #ai[
  1. Изчерпателно: ESP-IDF предоставя изчерпателен набор от софтуерни компоненти, драйвери и API за чиповете от сериите ESP32 и ESP32-S. Той включва широк набор от функции, като WiFi, Bluetooth и BLE, които могат да се използват за разработване на IoT устройства.
  2. Кросплатформеност: ESP-IDF поддържа междуплатформена разработка, което означава, че разработчиците могат да използват Windows, Linux или macOS, за да разработват приложения за ESP32. Това може да спести време и усилия, тъй като разработчиците могат да използват една и съща среда за разработка и инструменти за различни платформи.
  3. Документация: ESP-IDF има обширна документация, която включва ръководства за започване на работа, ръководства за програмиране и референции за API. Това може да помогне на разработчиците бързо да научат как да използват ESP-IDF и да разработват приложения за ESP32.
  4. Примери: ESP-IDF предоставя широк набор от примери, които демонстрират как да се използват различни функции на ESP32. Тези примери могат да помогнат на разработчиците бързо да научат как да използват ESP-IDF и да разработват приложения за ESP32.
  5. Общност: ESP-IDF разполага с голяма и активна общност от разработчици, които могат да осигурят поддръжка и да помогнат за отстраняване на проблеми. Това може да бъде особено полезно за новите разработчици, които се учат как да използват ESP-IDF и да разработват приложения за ESP32.

  1. Сложност: ESP-IDF може да бъде сложен и непосилен за новите разработчици. Тя включва широк набор от функции и API, които могат да бъдат предизвикателство за научаване и използване.
  2. Крива на обучение: ESP-IDF има стръмна крива на обучение, особено за разработчици, които са нови в разработването на вградени системи. Тя изисква добро разбиране на програмирането на C и на концепциите за вградени системи.
  3. Отстраняване на грешки: Отстраняването на грешки в ESP-IDF приложенията може да бъде предизвикателство, особено за новите разработчици. Ограничените ресурси на ESP32 и липсата на инструменти за отстраняване на грешки могат да затруднят идентифицирането и отстраняването на проблеми.
  4. Размер: ESP-IDF приложенията могат да бъдат големи и да консумират значително количество памет. Това може да е проблем за разработчиците, които разработват приложения за устройства с ограничени ресурси.
  5. Грешки: ESP-IDF все още е в процес на активна разработка и е възможно да има грешки и проблеми, които не са идентифицирани или отстранени. Това може да бъде разочароващо за разработчиците, които се сблъскват с проблеми и трябва да чакат за поправки или заобиколни решения.
  ]


== Електродвигател
_Електродвигателят_ (още известен като _електромотор_ или просто _мотор_) е машина преобразуваща
електрическата енергия в кинетична такава, най-често чрез електромагнетизъм.
Всеки двигател има подвижна и неподвижна част, наречени съответно _ротор_ и _статор_.
Основната цел на проекта е движението на паяка, следователно трябва да се избере подходящ двигател.
Разглеждат се няколко възможности:

#todo[https://bg.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%BE%D0%BC%D0%BE%D1%82%D0%BE%D1%80]

=== Постояннотоков двигател
Подвижната част от постояннотоковият двигател представлява електромагнит, а неподвижната - магнит.
Електромагнитът е захранен по такъв начин, че полюсите му съвпадат с тези на магнита.
Поради действащите сили ротора се завърта, а с неговото завъртане полюсите се променят, започвайки процесът наново.

Употребата на двигателят е много лесна: захранва се с определено напрежение.
Посоката на въртене зависи от поляритета на подаденото напрежение.

Не може пряко да се управлява скоростта на движение, което прави този двигател неподходящ за проекта.

#ai[
Постоянно токовите мотори са изключително разпространени в различни приложения, включително в индустрията, транспорта, домакинствата и др. Техните предимства включват висока ефективност, лесно управление на скоростта и възможност за работа в широк диапазон от скорости и натоварвания. Те са особено подходящи за приложения, които изискват висока мощност и прецизно контролиране, като например в електрическите превозни средства, фабрики за производство и машини за обработка на материали.
]

#todo[фигура]
#todo[https://bg.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_%D0%B5%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D0%B4%D0%B2%D0%B8%D0%B3%D0%B0%D1%82%D0%B5%D0%BB]

=== Стъпков двигател
#todo[]
#ai[
Стъпковият мотор е вид двигател, който работи чрез последователно движение на стъпките или чековете, които се придвижват в определен ред. Тези стъпки се движат под контрола на електроника и се използват в различни промишлени и научни приложения, както и в различни видове машини.

Един от основните компоненти на стъпковия мотор е роторът, който се състои от редица стъпки или чекове, които са аранжирани по специфичен начин. Тези чекове се движат по определен ред и това движение се осигурява от електрически сигнали, които се подават на мотора. В зависимост от конструкцията и приложението, стъпковият мотор може да има различен брой стъпки и конфигурации на чековете.

Една от ключовите предимства на стъпковите мотори е тяхната прецизност и контролируемост. Те могат да се придвижват с много малки стъпки, което позволява изключително висока точност при позициониране. Това ги прави идеални за приложения, където се изисква висока прецизност, като например в принтери, CNC машини, медицинска техника и роботика.

Освен това, стъпковите мотори са изключително надеждни и издръжливи. Те обикновено не изискват поддръжка и имат дълъг експлоатационен живот. Техните компактни размери и лека конструкция ги правят подходящи за вграждане в различни устройства и системи.

В заключение, стъпковите мотори са важен компонент във множество съвременни технологии и приложения, където се изисква висока прецизност, контрол и надежност. Техните уникални характеристики ги правят незаменими в различни индустрии и сектори.
]

=== Серводвигател <серво>

_Серводвигателят_ #footnote[Още известен като _сервомотор_ или просто _серво_. Произлиза от латинското #smallcaps[servus] _слуга_. Пълен български превод би бил _служещ двигател_ или _служедвигател_. Такъв превод не е използван в труда, за да не затрудни читателя.]
позволява завъртъне в желано от потребителя положение.
Подвижната част е свързана към неподвижната чрез потенциометър, който измерва действителното положение.
След като сравни желаното с действителното положение, сервото задвижва постояннотоков двигател в нужната посока.
Този принцип на действие кара двигателя да оказва съпротивление, когато се оказва сила върху ротора (напр. тази на гравитацията).

#ai[Основните компоненти на серво мотора включват самия двигател, енкодер (често оптичен), усилвател (за управление на електромотора), и контролер (който получава команди и генерира сигнали за управление на мотора). Енкодерът играе ключова роля за определяне на текущата позиция и скорост на мотора, като предоставя обратна връзка към контролера.]

Единствен недостатък на серводвигателя е ограниченият му размах, причинен от потенциометъра в него.
Докато повечето двигатели се въртят безкрайно, сервото има определен ъгъл на завъртане, рядко по-голям от 180°.
Този недостатък не оказва влияние на проекта.

За всички стави на крака е избран серводвигател sg90. Той има следните свойства:
- захранва се на 5В постоянно напрежение
- управлява се чрез широчинно-импулсна модулация (@шим),
- тежи 9г,
- прилага 1,4кгсм тяга,

== Потенциометър
#ai[
Потенциометърът е електронен компонент, който играе важна роля в регулирането на съпротивлението в електрическите вериги. Той се използва за промяна на съпротивлението чрез промяна на позицията на подвижния контакт върху проводниковата пътека. Потенциометрите се предлагат в различни размери и типове, като най-общо срещаните са линеен и обратен (логаритмичен) тип.

Линейните потенциометри имат постоянно увеличаващо се съпротивление в целия ход на подвижния контакт, докато обратните потенциометри имат съпротивление, което се увеличава нелинеарно с преместването на контакта. Обратните потенциометри се използват по-често в аудиоапаратурата, тъй като човешкото ухо е по-чувствително към логаритмични промени в силата на звука.

Потенциометрите се използват в широк спектър от приложения, включително усилватели, регулатори на осветление, силови източници, аудиоапаратура, инструменти за измерване и много други. Техните малки размери и удобството за интеграция ги правят незаменими компоненти в много електронни устройства и системи.
]

#todo[фигура]
#todo[https://www.ardboard.com/index.php?route=product/product&product_id=61&search=sg90]

= Изисквания
#todo[Да съдържа функционалните и електрическите изисквания към проектираното устройство (точка 2.1.), блокова схема на устройството, описание на предназначението и функциите на отделните блокове ( максимум 6-8 страници );]
#todo[брой крака]
#todo[ААА срещу гейската литиево-ьонна батерия]
#todo[Комуникация]

= Електроника
#todo[Същинската част на ДР с най - голям обем.  Да включва описание на принципните електрически  схеми на отделните блокове или на цялото устройство, информация за използваната елементна база, изчислителна записка, симулации на цялото устройство или на отделни блокове, графики, характеристики, анализи ( максимум 10-15 страници );]

#figure(image("blok-shema.png", width: 100%), caption: [Блок схема на проекта])

== Широчинно-импулсна модулация <шим>

#todo[източници]

#todo[фигура]

Широчинно-импулсната модулация (шим #footnote[Правилно е да се пише _ШИМ_. Тъй като терминът се среща често в труда, е написан с малки букви, за да не натоварва читателя.])
е популярен и ефективен подход, използван за управление на мощността, подавана към електрически товар, който може да бъде двигател, лампа или друго електрическо устройство, както и за комуникация.
Това е вид техника за модулация, която се състои в бързо превключване на сигнал между две нива, обикновено високо и ниско, с променлив работен цикъл.
Терминът _широчина на импулса_ се отнася до продължителността или дължината на високия сигнал.
Терминът _коефициент на запълване_ се отнася до съотношението между широчината на импулса и неговия период.

С други думи, шим е техника, при която се създава поредица от импулси с фиксирана честота, но с променлива ширина.

Шим сигналите могат да се генерират по различни начини, включително чрез цифрово-сигнални процесори (DSP), микроконтролери и специализирани интегрални схеми (ИС).
Изборът на подход зависи от конкретното приложение и изискваната производителност.

Избраният за проекта микроконтролерът Есп32, включва хардуерна поддръжка на шим.
Есп32 разполага с 16 шим канала, като всеки от тях има собствен набор от конфигурационни регистри.
Това позволява независимо управление достатъчно шим сигнали за повечето проекти.

16-те канала на Есп32 са разделени на две групи от по 8 канала.
Едната група канали работи в режим на висока скорост.
Този режим е реализиран хардуерно и предлага автоматична и безпроблемна промяна на коефициента на запълване.
Другата група канали работи в режим на ниска скорост, като коефициентът на запълване трябва да се променя софтуерно.
Всяка група канали може да използва различни източници на тактова честота.
Поради ниската честота, изисквана при работата със серводвигателите, разликата между бързите и бавните канали не оказва влияние.

https://docs.espressif.com/projects/esp-idf/en/v4.3/esp32/api-reference/peripherals/ledc.html?highlight=ledc_timer_config_t#_CPPv419ledc_timer_config_t

Избраният за проекта серводвигател (@серво) се управлява с шим сигнал с честота 50Хц, което е еквивалентно на период от 20мс.
При този подход завъртането на двигателя зависи от широчината на импулса на шим сигнала.

Според документацията #todo[коя] ъглите между 0° и 180° съответстват на широчини на импулса между 1мс и 2мс.
Въпреки това, експериментите с мотора, както и обратната връзка от други клиенти #todo[източник], показват, че действителните широчини на импулса са между 0.5мс и 2.5мс, като документираните 1мс до 2мс позволяват само 90° размах.

Точното преобразуване от желан ъгъл към шим сигнал е детайлно обяснено в @серво-контролер. В нея се взима предвид експериментално доказания обхват от 0.5мс до 2.5мс.

= Механика
#todo[Да съдържа описание на особеностите при проектирането на печатните платки с конструктивна  CAD система, графичните оригинали на страна елементи и страна спойки, вътрешни и захранващи слоеве на печатните платки, ситопечат, спецификация на елементите и използваните корпуси ( максимум 5-8 страници) ;]
#todo[кад]

= Логика
#todo[Да съдържа описание на алгоритъма и сорс кода на управляващия софтуер със съответна коментарна част и обяснения ( максимум 5-10 страници). ]

== Серво контролер <серво-контролер>

Както пише в @шим, завъртанията между 0° и 180° отговарят на широчина на импулса между 0.5мс и 2.5мс:
$
"широчина на импулса" &= частно("завъртане", 180°)2"мс" + 0.5"мс" \
                     &= частно("завъртане" + 45°, 90°)"мс"
$

При есп32 микроконтролера, шим сигнала се управлява чрез параметър `duty_cycle`, който спазва следната закономерност:
$
частно(печатно("duty_cycle"), 2^"резолюция") = частно("широчина на импулса", "период")
$

Знаейки, че $"период" = 20"мс"$, и че за 50Хц $"резолюция" = 20$ можем да изчислим `duty_cycle`:
$
частно(печатно("duty_cycle"), 2^20) &= частно(частно("завъртане" + 45°, 90°)съкращаваме("мс"), 20съкращаваме("мс")) \
печатно("duty_cycle")                        &= частно("завъртане" + 45°, 1800°) 2^20 &&печатно(#[ако _завъртане_ е в градуси]) \
печатно("duty_cycle")                        &= частно("завъртане" + частно(пи, 4), 10пи) 2^20 &&печатно(#[ако _завъртане_ е в радиани])
$

https://gist.github.com/benpeoples/3aa57bffc0f26ede6623ca520f26628c
https://raspberrypi.stackexchange.com/questions/106858/what-is-the-proper-calculation-of-duty-cycle-range-for-the-sg90-servo
https://www.friendlywire.com/projects/ne555-servo-safe/SG90-datasheet.pdf

== Обратна кинематика
#ai[
Обратната кинематика е ключов концепт в областта на роботиката и машиностроенето. Тя се отнася до методите и алгоритмите, използвани за определяне на позицията, ориентацията и движението на механични системи, като например роботи или манипулатори. Във връзка с това обратната кинематика се фокусира върху преобразуването на желаното пространствено движение (например координатите на крайната точка на робота) в съответните степени на свобода или параметри на системата (например ъгли на съчлененията).

За разлика от пряката кинематика, където се изчисляват пространствените параметри на механичната система, като се имат предвид параметрите на съчлененията, обратната кинематика прави обратното: от познатите параметри на пространството се определят параметрите на съчлененията. Това е особено полезно при програмирането на роботи, където операторът желае да дефинира пътя или позицията, която трябва да бъде достигната от робота, и роботът трябва автоматично да изчисли как да промени позицията на своите съчленения, за да постигне желаната позиция.

Обратната кинематика играе ключова роля във виртуалната реалност, компютърната анимация и медицинските приложения, като например симулацията на движението на човешкия скелет или операции с роботи в медицината. Тя предоставя мощни инструменти за управление и контрол на механични системи, които се използват в широка гама от области, включително производството, автоматизацията и изследователската дейност.
]

Подвижните части на всеки един крак са два кокъла $к_1$ и $к_2$ и три серво мотора $с_0$, $с_1$ и $с_2$.
Задачата е имайки желани кординати $ъ$, $ю$ и $в$ и дължините на костите,
да разберем стойностите на трите серво мотора които ще закарат стъпалото в тези кординати.

#figure(image("goren.png", width: 50%), caption: [Горен изглед])
$
с_0 &= атан2(ъ, ю) &печатно("по определение") \
р   &= корен(ъ^2 + ю^2) &печатно("по питагоровата теорема") \
$

#figure(image("straniqen.png", width: 50%), caption: [Страничен изглед])

$
&к = корен(р^2 + в^2) &печатно("по питагоровата теорема") \
$

$
&к^2 = к_1^2 + к_2^2 - 2к_1к_2кос(с_2 - пи) &печатно("по косинусовата теорема") \
&с_2 = пи + кос^(-1)частно(к^2 - к_1^2 - к_2^2, -2к_1к_2) \
&с_2 = пи + кос^(-1)частно(к_1^2 + к_2^2 - р^2 - в^2, 2к_1к_2) \
$

$
&theta = атан2(в, р)
$

$
&angle.spheric к_1к_2 = с_1 - theta \
&к_2^2 = к^2 + к_2^2 - 2к к_2кос(с_1 - theta) &печатно("по косинусовата теорема") \
&с_1 = theta + кос^(-1)частно(к_2^2 - к^2 - к_1^2, -2к к_1) \
&с_1 = атан2(в, р) + кос^(-1)частно(р^2 + в^2 + к_1^2 - к_2^2, 2к_1 корен(р^2 + в^2)) \
$

#todo[свържи уравненията]

== Походка
#todo[разсъждения върху един следващ крак]

= Изпълнение
#todo[Да съдържа описание и особеностите при създаването на работоспособен модел на проектираното устройство, както и фигури със снимки на външния вид на макета или монтираната печатна платка ( максимум 5-6 страници). Може и да липсва, ако няма разработен макет на устройството;]

файлът `export.sh` е почти като този даден от espresiff освен че задава IDF_PATH и PS1

#ai[
To use PWM on the ESP32, you first need to configure the desired PWM channel by setting the appropriate registers. This includes selecting the PWM signal's frequency, duty cycle, and output mode (i.e., whether the signal is active-high or active-low). Once configured, the PWM signal can be started and stopped as needed.Here's a high-level overview of the steps required to configure and use PWM on the ESP32:1.Configure the clock system: The ESP32's PWM peripheral uses a clock source to generate the PWM signal. You can configure the clock source and divider to achieve the desired PWM frequency.2.Select a PWM channel: The ESP32 has multiple PWM channels, each with its own set of configuration registers. Choose the appropriate channel for your application.3.Configure the PWM signal: Set the desired frequency, duty cycle, and output mode for the PWM signal.4.Enable the PWM channel: Once configured, enable the PWM channel to start generating the PWM signal.5.Control the PWM signal: You can adjust the duty cycle or stop the PWM signal as needed.
]

#heading(numbering: none)[Заключение]
#todo[включва обобщение на постиженията в дипломната работа и виждане за усъвършенстване и обогатяване на разработката – 1 страница;]

#heading(numbering: none)[Литература]
#todo[]

// #bilbliography("")

= Приложения
#todo[]

#outline(title: [Съдържание])

_Изкуственият интелект ще замени ли паяците?_

